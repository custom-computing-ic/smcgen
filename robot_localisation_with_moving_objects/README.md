### About

This is a simple example of using the SMC engine for localisation of a mobile robot in an environment with moving objects.

For details about the algorithm, see this paper
 * D. Montemerlo, S. Thrun, and W. Whittaker, "Conditional particle filters for simultaneous mobile robot localization and people-tracking," in Proc. Int. Conf. Robotics and Automation, 2002, pp.695-701. [link](http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1013439&isnumber=21826)

### Input

 * `src/data_y.txt` - observations (sensor readings), generated by `gen_obsrv.sh` based on true states (positions) `src/data_x.txt`.

### Output

 * `build/data_xest_[test_id].txt` - estimated states.

### Functions

 * Application specific functions are described in `src/Func.maxj` and `src/Func.c`.
```
/* Func.maxj */
/* User customised sampling function */
public static DFEStruct sampling(SmcKernel smc, DFEStruct s_in, DFEStruct r_in, DFEStruct seeds, DFEVar S, DFEVar idxInP) {
	...
}
/* User customised weighting function */
public static DFEVar weighting(SmcKernel smc, DFEStruct s_in, DFEVector<DFEVar> o_in, DFEVar w_in, DFEVar n, DFEVar h, DFEVar p, DFEVar idxInP, DFEVar idxOfP) {
	...
}
```
```
/* Func.c */
/*** FPGA mode: Call SMC core */
void smcFPGA(int NP, int slotOfAllP, float S, int itl_outer, int outer_idx, int itl_inner, float* state_in, float* ref_in, int* seed, float* obsrv_in, float* state_out, max_file_t* maxfile, max_engarray_t* engines){
	...
}
...
```

### Paramters

* Design and system parameters are described in `src/Def.maxj` and `src/Def.h`.
```
/* Def.maxj */
public class Def {

	/*** Computation precision */
	static final DFEType float_t = KernelLib.dfeFloat(8, 24);
	static final DFEType float_short_t = KernelLib.dfeFloat(7,20);
	static final DFEType fixed_t = KernelLib.dfeFixOffset(26, -20, SignMode.TWOSCOMPLEMENT);
	static final DFEType fixed_long_t = KernelLib.dfeFixOffset(30, -20, SignMode.TWOSCOMPLEMENT);

	/*** Seeds struct */
	public static final DFEStructType seeds_t = new DFEStructType(
		new StructFieldType("a", KernelLib.dfeRawBits(128)),
		new StructFieldType("b", KernelLib.dfeRawBits(128)),
		new StructFieldType("c", KernelLib.dfeRawBits(128))
	);
	public static int seed_slot = 3;

	/*** State struct */
	public static final DFEStructType state_t = new DFEStructType(
		new StructFieldType("x", float_t),
		new StructFieldType("y", float_t),
		new StructFieldType("h", float_t)
	);
	public static int state_slot = 3;

	/*** Reference struct */
	public static final DFEStructType ref_t = new DFEStructType(
		new StructFieldType("d", float_t),
		new StructFieldType("r", float_t)
	);
	public static int ref_slot = 2;

	/*** Particle struct */
	public static final DFEStructType particle_t = new DFEStructType(
		new StructFieldType("w", float_t),
		new StructFieldType("s", state_t)
	);

	/*** Design Parameters */
	public static int NPMin = 10240; // Minimum number of particles allowed
	public static int NPMax = 10240; // Maximum number of particle allowed
	...

	/*** System Parameters */
	public static int NC_inner = 1; // Parallelisation along itl_inner, between 1 and 4 inclusive
	public static int NC_P = 2; // Parallelisation along NP, should be divisor of NP
	public static int Clk_core = 100; // FPGA core clock frequency
	public static int Clk_mem = 333; // FPGA onboard DRAM frequency
	public static int FPGA_resampling = 0; // 1: resampling on FPGA; 0: resampling on CPU

	/*** Application Parameters */
	public static int NWall = 8;
	public static int NSensor = 20;
	public static int NPObj = 1017;
	public static int Obj = 7;
	public static int slotOfP = NPObj*Obj+1;
	public static float h_step = 2.0f*3.14159265359f/(NSensor*1.0f);
	...
}
```
```
/* Def.h */
/* Debug mode */
#ifndef debug
//#define debug
#endif

/* FPGA usage control */
/* enable: use FPGA; disable: use CPU for all processes */
#ifndef Use_FPGA
#define Use_FPGA 
#endif

/* Number of CPU threads */
#ifndef THREADS
#define THREADS	4
#endif

/* Number of steps */
#ifndef NT
#define NT		1
#endif

/* Number of robot particles */
// 16384
#ifndef NPMin
#define NPMin 5000
#endif
#ifndef NPMax
#define NPMax 25000
#endif

/* Number of moving object particles per robot particles */
#ifndef NPObj
#define NPObj 1017
#endif

/* Number of moving objects */
#ifndef Obj
#define Obj 7
#endif

/* Number of slots in a particle */
// 1+Obj*NPObj
// R:|0,1,...,Obj-1|...|0,1,...,Obj-1|
#ifndef slotOfP
#define slotOfP 7120
#endif

/* Horizon length */
#ifndef H
#define H  	1
#endif

/* Number of FPGA cores */
/* NC_inner * NC_P */
#ifndef NC
#define NC	2
#endif

/* Number of FPGA boards */
#ifndef NBoard
#define NBoard	1
#endif

/* Number of state slots */
#ifndef SS
#define SS 3
#endif

/* Number of reference slots */
#ifndef RS
#define RS 2
#endif

/* Number of sensors on a robot */
#ifndef NSensor
#define NSensor 20
#endif

/* Number of test to get the average error */
#ifndef NTest
#define NTest 5
#endif
```

### How to run

 * Simulation:
 	* `make runsim`
 * Build hardware:
 	* `make build`
 * Run hardware:
 	* `make run`
