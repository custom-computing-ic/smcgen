/* vim: set filetype=java : */
/* User has to customise this file */

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;

public class Func{

	/* User customised sampling function */
	public static DFEStruct sampling(SmcKernel smc, DFEStruct s_in, DFEStruct r_in, DFEStruct seeds, DFEVar S, DFEVar idxInP) {

		DFEStruct s_out = Def.state_t.newInstance(smc);

		DFEVar dist = r_in.get("d");
		DFEVar rot = r_in.get("r");
		DFEVar x = s_in.get("x");
		DFEVar y = s_in.get("y");
		DFEVar h = s_in.get("h");

		DFEVar seed_a = seeds.get("a");
		DFEVar seed_b = seeds.get("b");
		DFEVar seed_c = seeds.get("c");
		
		s_out.get("x") <== idxInP===0 ? x + KMath.nrand(smc, seed_a, dist, S*0.5) * KMath.cos(h) : x;
		s_out.get("y") <== idxInP===0 ? y + KMath.nrand(smc, seed_b, dist, S*0.5) * KMath.sin(h) : y;
		s_out.get("h") <== idxInP===0 ? h + KMath.nrand(smc, seed_c, rot, S*0.1) : h;

		// Uncomment the line below for debugging
		//smc.debug.printf("Position: %f %f %f\n", x, y, h);

		return s_out;
	}

	/* User customised weighting function */
	public static DFEVar weighting(SmcKernel smc, DFEStruct s_in, DFEVector<DFEVar> o_in, DFEVar w_in, DFEVar n, DFEVar h, DFEVar p, DFEVar idxInP, DFEVar idxOfP, DFEVar weight_update) {

		// Observation input
		DFEVector<DFEVar> obsrv = o_in;
		DFEVector<DFEVar> obsrvHold = Reductions.streamHold(obsrv, n===0 & h===0 & p===0);

		// Score calculation
		DFEVector<DFEVar> obsrvEst = est(smc,s_in,idxInP,weight_update);
		DFEVector<DFEVar> base = Def.sensor_t.newInstance(smc);
		for (int i=0; i<Def.NSensor; i++){
			base[i] <== KMath.abs(obsrvEst[i]-obsrvHold[i]);
		}
		DFEVar score = KMath.exp(KMath.addTreeVector(base,0,19)/-200.0);
		// Weight accumulation
		DFEVar weight = score*w_in;

		// Uncomment the line below for debugging
		//smc.debug.printf("Score: %f\n", obsrvEst);
		//smc.debug.printf("Weight %f\n", weight);

		return weight;
	}

	/* Other user functions */

	// Calculate observation value based on state
	private static DFEVector<DFEVar> est(SmcKernel smc, DFEStruct s_in, DFEVar idxInP, DFEVar weight_update) {

		DFEVar x = s_in.get("x");
		DFEVar y = s_in.get("y");
		DFEVar h = s_in.get("h");
		DFEVar x_robot = Reductions.streamHold(x, idxInP===0);
		DFEVar y_robot = Reductions.streamHold(y, idxInP===0);
		DFEVar h_base = Reductions.streamHold(h, idxInP===0);

		// Map information
		DFEVector<DFEVar> ax = Def.wall_t.newInstance(smc);
		DFEVector<DFEVar> ay = Def.wall_t.newInstance(smc);
		DFEVector<DFEVar> bx = Def.wall_t.newInstance(smc);
		DFEVector<DFEVar> by = Def.wall_t.newInstance(smc);
		ax[0] <== smc.constant.var(Def.compType,0); ay[0] <== smc.constant.var(Def.compType,0); 
		bx[0] <== smc.constant.var(Def.compType,0); by[0] <== smc.constant.var(Def.compType,12);
		ax[1] <== smc.constant.var(Def.compType,0); ay[1] <== smc.constant.var(Def.compType,12); 
		bx[1] <== smc.constant.var(Def.compType,18); by[1] <== smc.constant.var(Def.compType,12);
		ax[2] <== smc.constant.var(Def.compType,18); ay[2] <== smc.constant.var(Def.compType,12); 
		bx[2] <== smc.constant.var(Def.compType,18); by[2] <== smc.constant.var(Def.compType,0);
		ax[3] <== smc.constant.var(Def.compType,18); ay[3] <== smc.constant.var(Def.compType,0); 
		bx[3] <== smc.constant.var(Def.compType,0); by[3] <== smc.constant.var(Def.compType,0);
		ax[4] <== smc.constant.var(Def.compType,0); ay[4] <== smc.constant.var(Def.compType,6); 
		bx[4] <== smc.constant.var(Def.compType,4); by[4] <== smc.constant.var(Def.compType,6);
		ax[5] <== smc.constant.var(Def.compType,8); ay[5] <== smc.constant.var(Def.compType,6); 
		bx[5] <== smc.constant.var(Def.compType,16); by[5] <== smc.constant.var(Def.compType,6);
		ax[6] <== smc.constant.var(Def.compType,6); ay[6] <== smc.constant.var(Def.compType,6); 
		bx[6] <== smc.constant.var(Def.compType,6); by[6] <== smc.constant.var(Def.compType,12);
		ax[7] <== smc.constant.var(Def.compType,12); ay[7] <== smc.constant.var(Def.compType,6); 
		bx[7] <== smc.constant.var(Def.compType,12); by[7] <== smc.constant.var(Def.compType,12);

		DFEVector<DFEVar> obsrvTmp = Def.sensor_t.newInstance(smc);
		DFEVector<DFEVar> obsrvEst = Def.sensor_t.newInstance(smc);
		DFEVector<DFEVar> obsrvRtn = Def.sensor_t.newInstance(smc);
		for (int i=0; i<Def.NSensor; i++){
			DFEVar h_curr = h_base + Def.h_step*i;
			DFEVar cos_h = KMath.cos(h_curr);
			DFEVar sin_h = KMath.sin(h_curr);
			// Calculate distances to walls
			DFEVector<DFEVar> dist = Def.wall_t.newInstance(smc);
			for (int j=0; j<Def.NWall; j++)
				dist[j] <== dist2Obj(smc,x,y,cos_h,sin_h,ax[j],ay[j],bx[j],by[j]);
			obsrvTmp[i] <== Reductions.streamHold(KMath.minTreeVector(dist,0,Def.NWall-1), idxInP===0);

			// Calculate distances to moving objects
			//smc.optimization.pushPipeliningFactor(0.0);
			//obsrvEst[i] <== weight_update ? obsrvTmp[i] : KMath.min(obsrvEst[i],dist2Obj(smc,x_robot,y_robot,cos_h,sin_h,x-0.2,y-0.2,x+0.2,y+0.2));
			//smc.optimization.popPipeliningFactor();
			obsrvEst[i] <== weight_update ? obsrvTmp[i] : dist2Obj(smc,x_robot,y_robot,cos_h,sin_h,x-0.2,y-0.2,x+0.2,y+0.2);
			obsrvRtn[i] <== KMath.minTreeStream(smc,obsrvEst[i],0,Def.Obj-1);
		}

		return obsrvRtn;
	}

	private static DFEVar dist2Obj(SmcKernel smc, DFEVar x, DFEVar y, DFEVar cos_h, DFEVar sin_h, DFEVar ax, DFEVar ay, DFEVar bx, DFEVar by){

		DFEVar dy = by-ay;
		DFEVar dx = bx-ax;
		DFEVar pa = dy * (ax-x) - dx * (ay-y);
		DFEVar pb = dy * cos_h - dx * sin_h;
		DFEVar temp = pb===0 ? 99 : pa/pb;
		DFEVar dist = temp < 0 ? 99 : temp;
		DFEVar x_check = x + dist * cos_h;
		DFEVar y_check = y + dist * sin_h;
		DFEVar cond_a = (x_check-ax)>=-0.01 & (x_check-bx)<=0.01;
		DFEVar cond_b = (x_check-ax)<=0.01 & (x_check-bx)>=-0.01;
		DFEVar cond_c = (y_check-ay)>=-0.01 & (y_check-by)<=0.01;
		DFEVar cond_d = (y_check-ay)<=0.01 & (y_check-by)>=-0.01;
		DFEVar cond_e = ((cond_a | cond_b) & (cond_c | cond_d));

		//smc.debug.printf("%f %f %f\n", x_check, y_check, dist);

		return cond_e ? dist : smc.constant.var(Def.compType,99);
	}

}
