/* vim: set filetype=java : */

import com.maxeler.maxcompiler.v0.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;

public class CDF2IndexKernel extends Kernel {

	static int loopSize = 50;

	protected CDF2IndexKernel(KernelParameters parameters) {
		super(parameters);

		DFEVar NP = io.scalarInput("NP", dfeUInt(MathUtils.bitsToRepresent(Def.NPMax))); // determined at run-time

		DFEVar y = control.count.makeCounter(
					control.count.makeParams(MathUtils.bitsToRepresent(Def.NPMax*Def.NA))
						.withWrapMode(WrapMode.STOP_AT_MAX)
						.withMax(NP*Def.NA)
				).getCount();

		DFEVar cdf_in = io.input("cdf", Def.compType, y.cast(NP.getType())!==(NP*Def.NA));
		DFEVar sum_in = io.input("sum", Def.compType, y>=NP*Def.NA-Def.NA & y<NP*Def.NA);

		// Write weights to memory in the first NP cycles
		Memory<DFEVar> cdfmemo = mem.alloc(Def.compType, Def.NPMax*Def.NA);
		cdfmemo.write(y.cast(dfeUInt(MathUtils.bitsToAddress(Def.NPMax*Def.NA))), cdf_in, y.cast(NP.getType())!==(NP*Def.NA));

		Counter pa_counter = control.count.makeCounter(
					control.count.makeParams(MathUtils.bitsToRepresent(loopSize))
						.withMax(loopSize)
				);
		DFEVar pa = pa_counter.getCount();
		Counter p_counter = control.count.makeCounter(
					control.count.makeParams(MathUtils.bitsToRepresent(Def.NPMax*4))
						.withEnable(pa_counter.getWrap())
						.withWrapMode(WrapMode.STOP_AT_MAX)
				);
		DFEVar p = p_counter.getCount();
		DFEVar a = (Def.NA==1) ? constant.var(dfeUInt(1),0) : pa.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NA-1)));
		DFEVar notLooping = pa < Def.NA;

		DFEVar p_long = p.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax)+2));
		DFEVar NP_long = NP.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax)+2));
		DFEVar NP3_long = NP.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax)+2))*3;

		DFEVar k = dfeUInt(MathUtils.bitsToRepresent(Def.NPMax)).newInstance(this);
		DFEVar j = dfeUInt(MathUtils.bitsToRepresent(Def.NPMax)).newInstance(this);
		DFEVar didFind = dfeBool().newInstance(this);

		// Read weights and stored resampled index from cycle NP to 3NP-1
		DFEVar cdfmemoAddr = (Def.NA==1) ? k.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1))) : k.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1))) # a;
		DFEVar cdf = cdfmemo.read(cdfmemoAddr);

		k <== p===(NP).cast(p.getType()) ? 0 : (stream.offset(k, -loopSize) + (didFind ? 0 : constant.var(k.getType(), 1))); // resampled index
		j <== p===(NP).cast(p.getType()) ? 0 : (stream.offset(j, -loopSize) + (didFind ? 1 : constant.var(j.getType(), 0))); // index count

		DFEVar rand = io.input("rand", Def.compType, p_long===NP.cast(p_long.getType()) & pa < (Def.NA<4 ? 4 : Def.NA));
		DFEVar uj = Def.compType.newInstance(this);
		if (Def.NA>1){
			Memory<DFEVar> rmemo = mem.alloc(Def.compType, Def.NA);
			rmemo.write(a, rand, p_long===NP_long & notLooping);
			uj <== j.cast(Def.compType)/NP.cast(Def.compType) + rmemo.read(a);
		}else{
			DFEVar randHold = Reductions.streamHold(rand, p_long===NP_long & notLooping);
			uj <== j.cast(Def.compType)/NP.cast(Def.compType) + randHold;
		}
		DFEVar sum = Def.compType.newInstance(this);
		if (Def.NA>1){
			Memory<DFEVar> smemo = mem.alloc(Def.compType, Def.NA);
			smemo.write(a, sum_in, y>=NP*Def.NA-Def.NA & y<NP*Def.NA);
			sum <== smemo.read(a);
		}else{
			sum <== sum_in;
		}

		DFEVar found = (uj < cdf/sum);
		didFind <== stream.offset(found, -loopSize);

		Memory<DFEVar> imemo = mem.alloc(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1)), Def.NPMax*Def.NA);
		DFEVar imemoWrAddr = (Def.NA==1) ? j.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1))) : j.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1))) # a;
		imemo.write(imemoWrAddr, k.cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1))), found & notLooping & p_long >= NP_long & p_long < NP3_long & j.cast(NP.getType()) < NP);

		// Output weights from cycle 3NP to 4NP-1
		DFEVar imemoRdAddr = (Def.NA==1) ? (p-NP3_long).cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1))) : (p-NP3_long).cast(dfeUInt(MathUtils.bitsToRepresent(Def.NPMax-1))) # a;
		io.output("index", dfeUInt(32), p_long >= NP3_long & notLooping) <== imemo.read(imemoRdAddr).cast(dfeUInt(32));

		debug.printf(notLooping, "%d %f %f\n", p, cdf, sum);
		//debug.printf(found & notLooping & p_long >= NP_long & p_long < NP3_long & j.cast(NP.getType()) < NP, "%d %d %d\n", p, imemoWrAddr, k);
		//debug.printf(p_long >= NP3_long & notLooping, "%d %d %d %d\n", p_long, NP3_long, imemoRdAddr, imemo.read(imemoRdAddr).cast(dfeUInt(32)));

	}

}
